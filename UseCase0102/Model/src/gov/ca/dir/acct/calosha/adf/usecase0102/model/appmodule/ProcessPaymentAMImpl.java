package gov.ca.dir.acct.calosha.adf.usecase0102.model.appmodule;


//import gov.ca.dir.acct.calosha.adf.common.code.ViewObjectImpl;
import gov.ca.dir.acct.calosha.adf.usecase0102.model.appmodule.common.ProcessPaymentAM;
import gov.ca.dir.acct.cars.webservices.data.CARS215EventDetails;
import gov.ca.dir.acct.cars.webservices.data.CARS220EventDetails;
import gov.ca.dir.acct.cars.webservices.data.CARS225EventDetails;
import gov.ca.dir.acct.cars.webservices.data.CARS226EventDetails;
import gov.ca.dir.acct.cars.webservices.data.CARS245EventDetails;
import gov.ca.dir.acct.cars.webservices.data.CARSPacketDetails;
import gov.ca.dir.acct.calosha.adf.common.code.utils.CaloshaUtils;

import gov.ca.dir.acct.cars.webservices.data.utils.Address;
import gov.ca.dir.acct.cars.webservices.data.utils.CommonUtils;
import gov.ca.dir.acct.cars.webservices.data.utils.ContactMethodType;
import gov.ca.dir.acct.cars.webservices.data.utils.Organization;
import gov.ca.dir.acct.cars.webservices.proxy.Execute_ptClient;
import gov.ca.dir.acct.cars.webservices.struct.types.common.TEventType;

import gov.ca.dir.acct.cars.webservices.struct.types.common.TReceiptType;
import gov.ca.dir.acct.calosha.adf.common.code.utils.FiscalYearCalculator;

import gov.ca.dir.acct.calosha.adf.common.code.utils.ThirdPartyCollectionUtils;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

import java.math.BigDecimal;

import java.nio.charset.Charset;

import java.sql.CallableStatement;
import java.sql.SQLException;

import java.sql.Types;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.faces.application.FacesMessage;

import oracle.adf.model.BindingContext;
import oracle.adf.model.binding.DCBindingContainer;
import oracle.adf.model.binding.DCIteratorBinding;

import oracle.jbo.Key;
import oracle.jbo.NameValuePairs;
import oracle.jbo.Row;
import oracle.jbo.RowIterator;
import oracle.jbo.RowSetIterator;
import oracle.jbo.TooManyObjectsException;
import oracle.jbo.Variable;
import oracle.jbo.ViewCriteria;
import oracle.jbo.ViewObject;
import oracle.jbo.common.VariableImpl;
import oracle.jbo.domain.Date;
import oracle.jbo.domain.Number;
import oracle.jbo.jbotester.load.SimpleDateFormatter;
import oracle.jbo.server.ApplicationModuleImpl;
import oracle.jbo.server.SequenceImpl;
import oracle.jbo.server.TransactionEvent;
import oracle.jbo.server.ViewLinkImpl;


import oracle.jbo.server.ViewObjectImpl;

import org.w3c.dom.Document;

import org.w3c.dom.Element;

import org.w3c.dom.Node;

import org.w3c.dom.NodeList;
import javax.faces.context.FacesContext;


import utils.system;
// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Tue Jun 03 12:57:09 PDT 2014
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class ProcessPaymentAMImpl extends ApplicationModuleImpl implements ProcessPaymentAM {
    private CaloshaUtils caloshaUtils = new CaloshaUtils();
    private CARS215EventDetails cARS215EventDetails;//LOCKBOX
    private CARS220EventDetails cARS220EventDetails;//CREDIT CARD
    private CARS225EventDetails cARS225EventDetails;//EFT
    private CARS245EventDetails cARS245EventDetails;//Unbilled
    private CARS226EventDetails cARS226EventDetails;//EDD
    private CARSPacketDetails carsPacket;
    private String varAgencySourceCode;
    private String varRevenueSourceCode;
    private String varBillTypeCode;
    private String varIndex;
    private String varFund;
    private String varPcaCode;
    private String varInspectionNumber;
    private CommonUtils commonUtils;
    private oracle.jbo.domain.Number unappliedUnbilledItemId;
    private oracle.jbo.domain.Number depositTransmittalId;
    private oracle.jbo.domain.Number paymentId;
    private boolean isNotCommited = true;
    private boolean isPaymentExist;
    private HashMap<oracle.jbo.domain.Number,oracle.jbo.domain.Number > allocatedItems;
    private Number varInspectionId;
    private String varReferenceNumber;
    private String depositSlipNumber;



    /**
     * This is the default constructor (do not remove).
     */
    public ProcessPaymentAMImpl() {
    }


    /**
     * Container's getter for InspectionInformationView1.
     * @return InspectionInformationView1
     */
    public ViewObjectImpl getInspectionInformationView1() {
        return (ViewObjectImpl)findViewObject("InspectionInformationView1");
    }

    /**
     * Container's getter for BilledItemsView1.
     * @return BilledItemsView1
     */
    public ViewObjectImpl getBilledItemsView1() {
        return (ViewObjectImpl)findViewObject("BilledItemsView1");
    }


    /**
     * Container's getter for InspectionInformationBilledItemsView1.
     * @return InspectionInformationBilledItemsView1
     */
    public ViewLinkImpl getInspectionInformationBilledItemsView1() {
        return (ViewLinkImpl)findViewLink("InspectionInformationBilledItemsView1");
    }

    /**
     * Creates a Payment_Allocation entry for either Billed or Unbilled items
     * 
     */
    public void createPaymentAllocation(String allocationTypeCode,
                                        oracle.jbo.domain.Number citationId,
                                        oracle.jbo.domain.Number citationItemId,
                                        oracle.jbo.domain.Number inspectionId,
                                        oracle.jbo.domain.Number paymentId,
                                        oracle.jbo.domain.Number unbilledItemId,
                                        Date allocationDate,
                                        oracle.jbo.domain.Number allocatedAmount,
                                        String comments,
                                        String itemType,
                                        String referenceNumber)
                                        {
        ViewObjectImpl paymentAllocation = this.getPaymentAllocationView1();
        Row paymentAllocRow = paymentAllocation.createRow();
        if (itemType == "BILLED"){
            paymentAllocRow.setAttribute("CitationId", citationId);
            paymentAllocRow.setAttribute("CitationItemId", citationItemId);
            paymentAllocRow.setAttribute("InspectionId", inspectionId);
        }
        else if (itemType == "UNBILLED"){
            paymentAllocRow.setAttribute("UnbilledInspectionId", inspectionId);
            paymentAllocRow.setAttribute("UnbilledItemId", unbilledItemId);
        }
        else{}
        paymentAllocRow.setAttribute("PaymentId",  paymentId);
        paymentAllocRow.setAttribute("AllocatedAmount", allocatedAmount);
        paymentAllocRow.setAttribute("Comments", comments);
        paymentAllocRow.setAttribute("ReferenceNumber", referenceNumber);
        paymentAllocRow.validate();
    }


    /**
     * Exposed method that creates Related Party record given party_id. 
     * Defaults to ParticipantRoleTypeCode = PAYOR
     * @param paymentId
     */
    public void createRelatedParty(oracle.jbo.domain.Number paymentId){
        ViewObjectImpl relatedParty = this.getRelatedPartyView1();
        Row relatedPartyRow = relatedParty.createRow();
        relatedPartyRow.setAttribute("ParticipantRoleTypeCode", "PAYOR");
        ViewObjectImpl inspectionInformation = this.getInspectionInformationView1();
        oracle.jbo.domain.Number inspectionInformationParty;
        try {
            inspectionInformationParty = new oracle.jbo.domain.Number(inspectionInformation.getCurrentRow().getAttribute("PartyId").toString());
            relatedPartyRow.setAttribute("PartyId", inspectionInformationParty); 
            relatedPartyRow.setAttribute("PaymentId", paymentId); 
        } catch (SQLException e) {
        }
        
        relatedPartyRow.validate();
    }

    /**
     * Container's getter for UnbilledItemsView1.
     * @return UnbilledItemsView1
     */
    public ViewObjectImpl getUnbilledItemsView1() {
        return (ViewObjectImpl)findViewObject("UnbilledItemsView1");
    }

    /**
     * Container's getter for InspectionUnbilledItemsView1.
     * @return InspectionUnbilledItemsView1
     */
    public ViewLinkImpl getInspectionUnbilledItemsView1() {
        return (ViewLinkImpl)findViewLink("InspectionUnbilledItemsView1");
    }

    /**
     * Helper method that creates UnappliedUnbilledItem entry in case of unapplied payments.
     */
    public void createUnappliedUnbilledItem(oracle.jbo.domain.Number unappliedAmount1, String billTypeCode){
        ViewObjectImpl unbilledItemView = getUnbilledItemView1();
        Row unbilledItemRow = unbilledItemView.createRow();
        oracle.jbo.domain.Number inspectionId = null;
        
        this.setUnappliedUnbilledItemId(this.getUnbilledItemIdSequence());
        try {
            inspectionId = new oracle.jbo.domain.Number(this.getInspectionInformationView1().getCurrentRow().getAttribute("InspectionId").toString());
        } catch (SQLException e) {
        }
        oracle.jbo.domain.Number pafmId = this.getUnappliedPafmID(inspectionId,billTypeCode);
        unbilledItemRow.setAttribute("InspectionId", inspectionId);
        unbilledItemRow.setAttribute("UnbilledAmount", unappliedAmount1.round(2));
        unbilledItemRow.setAttribute("UnbilledItemId", this.getUnappliedUnbilledItemId());
        unbilledItemRow.setAttribute("PartyAgencyFundId", pafmId);
        unbilledItemRow.setAttribute("Status", "NEW");
        unbilledItemRow.validate();
    }


    /**
     * Helper method that gets the pafmId for unapplied payments given some inspectionId
     * @param inspectionId
     * @return partyAgencyFundId
     */
    private oracle.jbo.domain.Number getUnappliedPafmID(oracle.jbo.domain.Number inspectionId, String billTypeCode){
        ViewObjectImpl pafmView = this.getPartyAgencyFundMapView1();
        VariableImpl _partyCategoryBind = new VariableImpl();
        _partyCategoryBind.setName("partyCategory");
        VariableImpl _billTypeCodeBind = new VariableImpl();
        _billTypeCodeBind.setName("billTypeCode");
        VariableImpl _fy = new VariableImpl();
        _fy.setName("fiscalYear");
        
        Integer fy = getInspectionFiscalYear();
        
        Key itemKey = new Key(new Object[] { inspectionId.intValue() });
        String _partecategorycode = this.getInspectionInformationView1().findByKey(itemKey, 1)[0].getAttribute("PartyCategoryCode").toString();
        RowIterator pafmRowIter = pafmView.findByViewCriteriaWithBindVars(pafmView.getViewCriteria("PartyCategoryViewCriteria"), -1, pafmView.QUERY_MODE_SCAN_DATABASE_TABLES, new Variable[]{_partyCategoryBind, _billTypeCodeBind, _fy}, new Object[] {_partecategorycode,billTypeCode,fy});
        oracle.jbo.domain.Number _pafmId = null;
        if (pafmRowIter.hasNext()){
            Row pafmRow =pafmRowIter.next();
            _pafmId = (oracle.jbo.domain.Number) pafmRow.getAttribute("PartyAgencyFundMapId");
        }

        return _pafmId;
    }
    
    /**
     * Helper method that returns the fiscal year associated with the current invoice (inspection)
     * @return fy
     */
    private Integer getInspectionFiscalYear() {
        ViewObjectImpl inspectionView = this.getInspectionInformationView1();
        oracle.jbo.domain.Date jboDate= (oracle.jbo.domain.Date) inspectionView.getCurrentRow().getAttribute("IssueDate");
        GregorianCalendar eventDate = this.convertJboDateToGregorianDate(jboDate);
        Integer fy = (new FiscalYearCalculator(eventDate)).getFiscalYear();
        return fy;
    }


    /**
     * Helper method that creates unapplied payment allocation entries.
     */
    public void createUnappliedPaymentAllocation(oracle.jbo.domain.Number paymentUnappliedAmt){
        System.out.println("createUnappliedPaymentAllocation invoking");
        //ViewObjectImpl paymentView = this.getPaymentView1();
        //oracle.jbo.domain.Number paymentUnappliedAmt = (Number)((oracle.jbo.domain.Number) paymentView.getCurrentRow().getAttribute("UnappliedAmount")).round(2);
        if (paymentUnappliedAmt.doubleValue() > 0) {
            oracle.jbo.domain.Number inspectionId = (oracle.jbo.domain.Number) this.getInspectionInformationView1().getCurrentRow().getAttribute("InspectionId");
            ViewObjectImpl paymentAllocation = this.getPaymentAllocationView2();
            Row paymentAllocRow = paymentAllocation.createRow();
            paymentAllocRow.setAttribute("UnbilledItemId", this.getUnappliedUnbilledItemId());
            paymentAllocRow.setAttribute("UnbilledInspectionId", inspectionId);
            paymentAllocRow.setAttribute("PaymentId",  this.getPaymentId());
            paymentAllocRow.setAttribute("AllocatedAmount", paymentUnappliedAmt);
            oracle.jbo.domain.Number paymentAllocationId = getPaymentAllocationIdSequence();
            paymentAllocRow.setAttribute("PaymentAllocationId", paymentAllocationId);
            allocatedItems.put(paymentAllocationId, inspectionId);
            paymentAllocRow.validate();
        }
    }
    
    public void createUnappliedPaymentAllocation() {
    }
    
    
    /**
     * Get next Payment ID sequence number.
     * @return Naumber
     */
    public oracle.jbo.domain.Number getPaymentIdSequence(){
        return (new SequenceImpl("PAYMENT_ID_SEQ", getDBTransaction())).getSequenceNumber();
    }
    
    /**
     * Get next Unbilled Item ID sequence number.
     * @return Naumber
     */
    public oracle.jbo.domain.Number getUnbilledItemIdSequence(){
        return (new SequenceImpl("UNBILLED_ITEM_ID_SEQ", getDBTransaction())).getSequenceNumber();
    }
    
    /**
     * Get next Deposit Transmittal ID sequence number.
     * @return Naumber
     */
    public oracle.jbo.domain.Number getDepositTransmittalIdSequence(){
        return (new SequenceImpl("DEPOSIT_TRANSMITTAL_ID_SEQ", getDBTransaction())).getSequenceNumber();
    }

    /**
     * Get next Payment Allocation ID sequence number.
     * @return Naumber
     */
    public oracle.jbo.domain.Number getPaymentAllocationIdSequence(){
        return (new SequenceImpl("PAYMENT_ALLOCATION_ID_SEQ", getDBTransaction())).getSequenceNumber();
    }

    /**
     * Get next Third Party Collect ID sequence number.
     * @return Naumber
     */
    public oracle.jbo.domain.Number getThirdPartyCollectionIdSequence(){
        return (new SequenceImpl("THIRD_PARTY_COLLECT_ID_SEQ", getDBTransaction())).getSequenceNumber();
    }

    /**
     * Container's getter for UnbilledItemView1.
     * @return UnbilledItemView1
     */
    public ViewObjectImpl getUnbilledItemView1() {
        return (ViewObjectImpl)findViewObject("UnbilledItemView1");
    }

    /**
     * Container's getter for InspectionUnbilledItemView1.
     * @return InspectionUnbilledItemView1
     */
    public ViewLinkImpl getInspectionUnbilledItemView1() {
        return (ViewLinkImpl)findViewLink("InspectionUnbilledItemView1");
    }

    /**
     * Sets payment id for a payment for current payment row.
     */
    public void setPaymentId(oracle.jbo.domain.Number paymentId){
        oracle.jbo.domain.Number thisPaymentId = null;
        if (paymentId == null){
            thisPaymentId = this.getPaymentIdSequence();
        }else {
            thisPaymentId = paymentId;
        }
        ViewObjectImpl paymentView = this.getPaymentView1();
        Row paymentViewRow = paymentView.getCurrentRow();
        paymentViewRow.setAttribute("PaymentId", thisPaymentId);
        this.paymentId = thisPaymentId;
    }

    @Override
    /**
     * Commits current transaction and send events to CARS.
     */
    public void afterCommit(TransactionEvent transactionEvent) {
        super.afterCommit(transactionEvent);
        sendCARSEvents(); // send CARS events
    }

    /**
     * Main method that will assemble Event objects to be sent to CARS after transaction
     * commit is called.
     */
    private void sendCARSEvents() {
        if (this.getInspectionInformationView1().getCurrentRow() != null && !isNotCommited) {
           System.out.println("committed? " + isNotCommited);
            carsPacket = new CARSPacketDetails();
            Row currentInvoiceRow = this.getInspectionInformationView1().getCurrentRow();
            
            //get key values 
            varInspectionNumber = currentInvoiceRow.getAttribute("InspectionNumber") != null ? (String) currentInvoiceRow.getAttribute("InspectionNumber") : "";
            varInspectionId = currentInvoiceRow.getAttribute("InspectionId") != null ? (Number) currentInvoiceRow.getAttribute("InspectionId") : null;
            varIndex = currentInvoiceRow.getAttribute("IndexCode").toString();
            System.out.println("InspectionNumber " + varInspectionNumber);
            
            //get date values
            String username = (String)this.getPaymentView1().getCurrentRow().getAttribute("CreatedBy");
            GregorianCalendar submitDate = new GregorianCalendar();
            submitDate.setGregorianChange(Calendar.getInstance().getTime());
            oracle.jbo.domain.Date paymentDate =  (oracle.jbo.domain.Date) this.getPaymentView1().getCurrentRow().getAttribute("PaymentDate");
            GregorianCalendar eventDate = convertJboDateToGregorianDate(paymentDate);
            
            //get Resparty information    
            Organization organization = new Organization("PAYOR",1);
            Address address = new Address();
            
            String streetAddress = currentInvoiceRow.getAttribute("StreetAddress") != null ? (String) currentInvoiceRow.getAttribute("StreetAddress") : "";
            String addressLine2 = currentInvoiceRow.getAttribute("AddressLine2") != null ? (String) currentInvoiceRow.getAttribute("AddressLine2") : "";
            String city = currentInvoiceRow.getAttribute("City") != null ? (String) currentInvoiceRow.getAttribute("City") : "";
            String stateCode = currentInvoiceRow.getAttribute("StateCode") != null ? (String) currentInvoiceRow.getAttribute("StateCode") : "";
            String zipCode = currentInvoiceRow.getAttribute("ZipCode") != null ? (String) currentInvoiceRow.getAttribute("ZipCode").toString() : "";
            String zip4 = currentInvoiceRow.getAttribute("Zip4") != null ? (String) currentInvoiceRow.getAttribute("Zip4") : "";
            address.setAddress(streetAddress, addressLine2, "", city, "", stateCode, zipCode, zip4);
            organization.addAddress(address);
            
            Map<String, String> contactMethods = new HashMap<String, String>();
            if (currentInvoiceRow.getAttribute("ContactMethodValue") != null) {
                String phone = (String) currentInvoiceRow.getAttribute("ContactMethodValue");
                contactMethods.put(ContactMethodType.PHONE.name(), phone.replace("-", ""));
                organization.addContactMethods(contactMethods);
            }

            String dba = currentInvoiceRow.getAttribute("Dba") != null ? (String) currentInvoiceRow.getAttribute("Dba") : "";
            String fein = currentInvoiceRow.getAttribute("Fein") != null ? (String) currentInvoiceRow.getAttribute("Fein") : "";
            String legalName = currentInvoiceRow.getAttribute("LegalName") != null ? (String) currentInvoiceRow.getAttribute("LegalName") : "";
            String naicsCode = currentInvoiceRow.getAttribute("NaicsCode") != null ? (String) currentInvoiceRow.getAttribute("NaicsCode").toString() : "";
            String organizationName = currentInvoiceRow.getAttribute("OrganizationName") != null ? (String) currentInvoiceRow.getAttribute("OrganizationName") : "";
            String sein = currentInvoiceRow.getAttribute("Sein") != null ? (String) currentInvoiceRow.getAttribute("Sein").toString() : "";
            String sicCode = currentInvoiceRow.getAttribute("SicCode") != null ? (String) currentInvoiceRow.getAttribute("SicCode").toString() : "";
            organization.setOrganization(dba,fein,legalName,naicsCode,organizationName,sein,sicCode);
            organization.set();
            
            //call methods to generate Event Data for CC, EFT and EDD type payments
            //note: Events for Check payments are generate by the End Of Day module
            String paymentType = this.getPaymentView1().getCurrentRow().getAttribute("PaymentTypeCode").toString();
            if (paymentType.equals("VISA_MASTER_CREDIT_CARD") || paymentType.equals("AMEX_CREDIT_CARD") || paymentType.equals("DISCOVER_CREDIT_CARD")){
                sendCreditCardPaymentToCARS(username, submitDate, eventDate, organization, paymentType); 
                sendUnbilledPaymentToCARS(username, submitDate, eventDate, organization, paymentType);      
            } else if (paymentType.equals("EFT")) {
                sendEFTPaymentToCARS(username, submitDate, eventDate, organization);  
                sendUnbilledPaymentToCARS(username, submitDate, eventDate, organization, paymentType);   
            } else if (paymentType.equals("ACCOUNT_TRANSFER")) {
                sendEDDPaymentToCARS(username, submitDate, eventDate, organization); 
                sendUnbilledPaymentToCARS(username, submitDate, eventDate, organization, paymentType);   
            } else if (paymentType.equals("USB_LOCK_BOX")){
                sendLockboxPaymentToCARS(username, submitDate, eventDate, organization); 
                sendUnbilledPaymentToCARS(username, submitDate, eventDate, organization, paymentType);   
            }
            
            //set commited flag to avoid event duplication
            isNotCommited = true;
            
        }
    }

    /**
     * Helper method to set Event Accounting Code for Billed items using pafmId used by the given citation item.
     */
    private void setAccountingCodeUsingPafmId(Row citationItem) {
        int citationItemKey =  ((oracle.jbo.domain.Number)citationItem.getAttribute("CitationItemId")).intValue();
        
        //set pointer on Billed Item VO table to the proper citation item
        ViewObjectImpl billedItemsVo = this.getBilledItemsView2();
        Key citItemKey = new Key(new Object[] { citationItemKey });
        Number pafmId = (Number) billedItemsVo.findByKey(citItemKey, 1)[0].getAttribute("PartyAgencyFundMapId");
        Key itemKey = new Key(new Object[] {pafmId});
        
        //set Accounting Code variables
        varFund = (String) getPartyAgencyFundMapView1().findByKey(itemKey, 1)[0].getAttribute("FundId");
        varPcaCode = getPartyAgencyFundMapView1().findByKey(itemKey, 1)[0].getAttribute("PcaCode").toString(); 
        varAgencySourceCode = caloshaUtils.getRegularAgencySourceCode(
                (String) getPartyAgencyFundMapView1().findByKey(itemKey, 1)[0].getAttribute("AgencySourceCode"));
        varRevenueSourceCode =
                (String) getPartyAgencyFundMapView1().findByKey(itemKey, 1)[0].getAttribute("RevenueSourceCode");
    }
    
    /**
     * Helper method to set Event Accounting Code for Unbilled items using pafmId used by the given citation item.
     */   
    private void setAccountingCodeUsingPafmIdForUnbilled(Row unbilledItem) {
        int citationItemKey =  ((oracle.jbo.domain.Number)unbilledItem.getAttribute("UnbilledItemId")).intValue();
        //set pointer on Unbilled Item VO table to the proper citation item
        ViewObjectImpl unbilledItemsVo = this.getUnbilledItemsView2();
        Key citItemKey = new Key(new Object[] { citationItemKey });
        Number pafmId = (Number) unbilledItemsVo.findByKey(citItemKey, 1)[0].getAttribute("PartyAgencyFundId");
        Key itemKey = new Key(new Object[] {pafmId});
        
        //set Accounting Code variables
        varFund = (String) getPartyAgencyFundMapView1().findByKey(itemKey, 1)[0].getAttribute("FundId");
        varPcaCode = getPartyAgencyFundMapView1().findByKey(itemKey, 1)[0].getAttribute("PcaCode").toString(); 
        varAgencySourceCode = (String) getPartyAgencyFundMapView1().findByKey(itemKey, 1)[0].getAttribute("AgencySourceCode");
        varRevenueSourceCode =
                (String) getPartyAgencyFundMapView1().findByKey(itemKey, 1)[0].getAttribute("RevenueSourceCode");
    }
    
    /**
     * Utility method to convert jbo date to java GregorianCalendar date
     * @param paymentDate an oracle.jbo.domain.Date object
     * @return GregorianCalendar date
     */
    private GregorianCalendar convertJboDateToGregorianDate(oracle.jbo.domain.Date paymentDate) {
        java.sql.Date sqlDate = paymentDate.dateValue();
        long longDate = sqlDate.getTime();
        java.util.Date javaDate = new java.util.Date(longDate);
        GregorianCalendar eventDate = new GregorianCalendar();
        eventDate.setTime(javaDate);
        return eventDate;
    }
    
    
    /**
     * Method to assemble and send the data for EVENT220 Credit Card Payments event to CARS.
     */ 
    private void sendCreditCardPaymentToCARS(String username,
                                             GregorianCalendar submitDate,
                                             GregorianCalendar eventDate,
                                             Organization organization,
                                             String paymentType) {
        //create Event220 object 
        cARS220EventDetails = new CARS220EventDetails();
        cARS220EventDetails.setEventHeader("CALOSHA","CALOSHA-AR", username, submitDate);
        cARS220EventDetails.addParticipant(organization);
        cARS220EventDetails.set();

        ViewObjectImpl billedItemPaymentsView = this.getPaymentAllocationView3();
        RowSetIterator billedItemPaymentsRows = billedItemPaymentsView.createRowSetIterator(null);
        billedItemPaymentsRows.reset();
       
        //initiate helper variables
        Row paymentRow = this.getPaymentView1().getCurrentRow();
        BigDecimal _billedItemsTotal = new BigDecimal(0);
        TReceiptType pType = null;
        String depositSuffix = null;
        depositSuffix = getDepositSlipSuffix(paymentType);
        
        //send event for each payment allocated
        while (billedItemPaymentsRows.hasNext()){
            Row nextItem = billedItemPaymentsRows.next();

            setAccountingCodeUsingPafmId(nextItem);
            cARS220EventDetails.setAccountingCode(varAgencySourceCode,varRevenueSourceCode,varIndex,varFund, varPcaCode);

            oracle.jbo.domain.Number paymentAllocationId =
                            (Number)nextItem.getAttribute("PaymentAllocationId");

            Double allocAmount = nextItem.getAttribute("AllocatedAmount") != null ? ((oracle.jbo.domain.Number) nextItem.getAttribute("AllocatedAmount")).doubleValue():0d;
            //exclude unbilled items and check if there's amount still allocatable
            if (nextItem.getAttribute("UnbilledItemId") == null && allocAmount > 0 && allocatedItems.containsKey(paymentAllocationId) ){
                oracle.jbo.domain.Number val = (oracle.jbo.domain.Number) nextItem.getAttribute("AllocatedAmount");
                oracle.jbo.domain.Number itemId = (oracle.jbo.domain.Number) nextItem.getAttribute("PaymentAllocationId");
                String inspectionNumber = getInspectionNumber((oracle.jbo.domain.Number) nextItem.getAttribute("InspectionId"));
                String currentDocument = commonUtils.getDocumentNumber(inspectionNumber, "220", eventDate, itemId.toString());
                String _controlNumber = paymentRow.getAttribute("PaymentControlNumber").toString();
                cARS220EventDetails.setEventDetail(val.bigDecimalValue(),currentDocument,inspectionNumber,eventDate, _controlNumber, this.getPaymentType(paymentType).toString(), "OSH", getDepositNumber(eventDate,depositSuffix), eventDate);
                List<Object> lstpld = new ArrayList<Object>();
                lstpld.add(cARS220EventDetails.getEvent());
                prepareCARSPacketHeader(currentDocument,username,submitDate,TEventType.CARS_220_EVENT,lstpld);
                try {
                    System.out.println("Sending CC to CARS");
                    Execute_ptClient.invoke(carsPacket); //send event to CARS
                } catch (Exception e) {
                    e.printStackTrace();
                } 
            }
            
        }
        billedItemPaymentsRows.closeRowSetIterator(); //close iterator
    }

    /**
     * Method to assemble and send the data for EVENT225 EFT Payments event to CARS.
     */ 
    private void sendEFTPaymentToCARS(String username,
                                             GregorianCalendar submitDate,
                                             GregorianCalendar eventDate,
                                             Organization organization) {
        cARS225EventDetails = new CARS225EventDetails();
        cARS225EventDetails.setEventHeader("CALOSHA","CALOSHA-AR", username, submitDate);
        cARS225EventDetails.addParticipant(organization);
        cARS225EventDetails.set();

        ViewObjectImpl billedItemPaymentsView = this.getPaymentAllocationView3();

        RowSetIterator billedItemPaymentsRows = billedItemPaymentsView.createRowSetIterator(null);
        billedItemPaymentsRows.reset();
        Row paymentRow = this.getPaymentView1().getCurrentRow();
        BigDecimal _billedItemsTotal = new BigDecimal(0);
        while (billedItemPaymentsRows.hasNext()){
            Row nextItem = billedItemPaymentsRows.next();
            
            setAccountingCodeUsingPafmId(nextItem);
            cARS225EventDetails.setAccountingCode(varAgencySourceCode,varRevenueSourceCode,varIndex,varFund, varPcaCode);

            oracle.jbo.domain.Number paymentAllocationId =
                            (Number)nextItem.getAttribute("PaymentAllocationId");

            Double allocAmount = nextItem.getAttribute("AllocatedAmount") != null ? ((oracle.jbo.domain.Number) nextItem.getAttribute("AllocatedAmount")).doubleValue():0d;
            if (nextItem.getAttribute("UnbilledItemId") == null && allocAmount > 0 && allocatedItems.containsKey(paymentAllocationId) ){
                oracle.jbo.domain.Number val = (oracle.jbo.domain.Number) nextItem.getAttribute("AllocatedAmount");
                oracle.jbo.domain.Number itemId = (oracle.jbo.domain.Number) nextItem.getAttribute("PaymentAllocationId");
                String inspectionNumber = getInspectionNumber((oracle.jbo.domain.Number) nextItem.getAttribute("InspectionId"));
                String currentDocument = commonUtils.getDocumentNumber(inspectionNumber, "225", eventDate, itemId.toString());
                String _controlNumber = paymentRow.getAttribute("PaymentControlNumber").toString();
                cARS225EventDetails.setEventDetail(val.bigDecimalValue(),currentDocument,inspectionNumber,eventDate, _controlNumber,"OSH", getDepositNumber(eventDate,"04"), eventDate);
                List<Object> lstpld = new ArrayList<Object>();
                lstpld.add(cARS225EventDetails.getEvent());
                prepareCARSPacketHeader(currentDocument,username,submitDate,TEventType.CARS_225_EVENT,lstpld);
                try {
                    System.out.println("Sending EFT to CARS");
                    Execute_ptClient.invoke(carsPacket);
                } catch (Exception e) {
                    e.printStackTrace();
                } 
            }
        }
        billedItemPaymentsRows.closeRowSetIterator();
    }

    /**
     * Method to assemble and send the data for EVENT226 EDD Payments event to CARS.
     */ 
    private void sendEDDPaymentToCARS(String username,
                                             GregorianCalendar submitDate,
                                             GregorianCalendar eventDate,
                                             Organization organization) {
        cARS226EventDetails = new CARS226EventDetails();
        cARS226EventDetails.setEventHeader("CALOSHA","CALOSHA-AR", username, submitDate);
        cARS226EventDetails.addParticipant(organization);
        cARS226EventDetails.set();
        
        String depositSlip = getDepositSlipNumber();
        ViewObjectImpl billedItemPaymentsView = this.getPaymentAllocationView3();

        RowSetIterator billedItemPaymentsRows = billedItemPaymentsView.createRowSetIterator(null);
        billedItemPaymentsRows.reset();
        Row paymentRow = this.getPaymentView1().getCurrentRow();
        BigDecimal _billedItemsTotal = new BigDecimal(0);

        while (billedItemPaymentsRows.hasNext()){
            Row nextItem = billedItemPaymentsRows.next();
            
            setAccountingCodeUsingPafmId(nextItem);
            cARS226EventDetails.setAccountingCode(varAgencySourceCode,varRevenueSourceCode,varIndex,varFund, varPcaCode);

            oracle.jbo.domain.Number paymentAllocationId =
                            (Number)nextItem.getAttribute("PaymentAllocationId");

            Double allocAmount = nextItem.getAttribute("AllocatedAmount") != null ? ((oracle.jbo.domain.Number) nextItem.getAttribute("AllocatedAmount")).doubleValue():0d;
            if (nextItem.getAttribute("UnbilledItemId") == null && allocAmount > 0 && allocatedItems.containsKey(paymentAllocationId) ){
                oracle.jbo.domain.Number val = (oracle.jbo.domain.Number) nextItem.getAttribute("AllocatedAmount");
                oracle.jbo.domain.Number itemId = (oracle.jbo.domain.Number) nextItem.getAttribute("PaymentAllocationId");
                String inspectionNumber = getInspectionNumber((oracle.jbo.domain.Number) nextItem.getAttribute("InspectionId"));
                String currentDocument = commonUtils.getDocumentNumber(inspectionNumber, "226", eventDate, itemId.toString());
                String _controlNumber = paymentRow.getAttribute("PaymentControlNumber").toString();
                cARS226EventDetails.setEventDetail(val.bigDecimalValue(),currentDocument,inspectionNumber,eventDate, _controlNumber,"OSH", depositSlip, eventDate);
                List<Object> lstpld = new ArrayList<Object>();
                lstpld.add(cARS226EventDetails.getEvent());
                prepareCARSPacketHeader(currentDocument,username,submitDate,TEventType.CARS_226_EVENT,lstpld);
                try {
                    System.out.println("Sending EDD Payments to CARS");
                    Execute_ptClient.invoke(carsPacket);
                } catch (Exception e) {
                    e.printStackTrace();
                } 
            }
        }
        billedItemPaymentsRows.closeRowSetIterator();
    }

    /**
     * Method to assemble and send the data for EVENT215 Lockbox Payments event to CARS.
     */ 
    private void sendLockboxPaymentToCARS(String username,
                                             GregorianCalendar submitDate,
                                             GregorianCalendar eventDate,
                                             Organization organization) {
        cARS215EventDetails = new CARS215EventDetails();
        cARS215EventDetails.setEventHeader("CALOSHA","CALOSHA-AR", username, submitDate);
        cARS215EventDetails.addParticipant(organization);
        cARS215EventDetails.set();
        
        String depositSlip = getDepositSlipNumber();
        ViewObjectImpl billedItemPaymentsView = this.getPaymentAllocationView3();

        RowSetIterator billedItemPaymentsRows = billedItemPaymentsView.createRowSetIterator(null);
        billedItemPaymentsRows.reset();
        Row paymentRow = this.getPaymentView1().getCurrentRow();
        BigDecimal _billedItemsTotal = new BigDecimal(0);

        while (billedItemPaymentsRows.hasNext()){
            Row nextItem = billedItemPaymentsRows.next();
            
            setAccountingCodeUsingPafmId(nextItem);
            cARS215EventDetails.setAccountingCode(varAgencySourceCode,varRevenueSourceCode,varIndex,varFund, varPcaCode);

            oracle.jbo.domain.Number paymentAllocationId =
                            (Number)nextItem.getAttribute("PaymentAllocationId");

            Double allocAmount = nextItem.getAttribute("AllocatedAmount") != null ? ((oracle.jbo.domain.Number) nextItem.getAttribute("AllocatedAmount")).doubleValue():0d;
            if (nextItem.getAttribute("UnbilledItemId") == null && allocAmount > 0 && allocatedItems.containsKey(paymentAllocationId) ){
                oracle.jbo.domain.Number val = (oracle.jbo.domain.Number) nextItem.getAttribute("AllocatedAmount");
                oracle.jbo.domain.Number itemId = (oracle.jbo.domain.Number) nextItem.getAttribute("PaymentAllocationId");
                String inspectionNumber = getInspectionNumber((oracle.jbo.domain.Number) nextItem.getAttribute("InspectionId"));
                String currentDocument = commonUtils.getDocumentNumber(inspectionNumber, "215", eventDate, itemId.toString());
                String _controlNumber = paymentRow.getAttribute("PaymentControlNumber").toString();
                String paymentTypeCode = paymentRow.getAttribute("PaymentTypeCode").toString();
                cARS215EventDetails.setEventDetail(val.bigDecimalValue(),currentDocument,inspectionNumber,eventDate, _controlNumber, paymentTypeCode,"OSH", depositSlip, eventDate);
                List<Object> lstpld = new ArrayList<Object>();
                lstpld.add(cARS215EventDetails.getEvent());
                prepareCARSPacketHeader(currentDocument,username,submitDate,TEventType.CARS_215_EVENT,lstpld);
                try {
                    System.out.println("Sending Lockbox Payments to CARS");
                    Execute_ptClient.invoke(carsPacket);
                } catch (Exception e) {
                    e.printStackTrace();
                } 
            }
        }
        billedItemPaymentsRows.closeRowSetIterator();
    }
    
    /**
     * Method to assemble and send the data for EVENT245 Unbilled Payment event to CARS.
     */    
    private void sendUnbilledPaymentToCARS(String username,
                                             GregorianCalendar submitDate,
                                             GregorianCalendar eventDate,
                                             Organization organization,
                                           String paymentType) {
        
        //initiate object variables
        ViewObjectImpl inspectionView = this.getInspectionInformationView2();
        Integer fy = getInspectionFiscalYear();
        String partyCat = this.getPartyCategory();
        
        //intiate CARS245EventDetials object
        cARS245EventDetails = new CARS245EventDetails();
        cARS245EventDetails.setEventHeader("CALOSHA","CALOSHA-AR", username, submitDate);
        cARS245EventDetails.addParticipant(organization);
        cARS245EventDetails.set();
        
        //get unbilled items view and requery to ensure data is fresh   
        ViewObjectImpl unbilledItemPaymentsView = this.getPaymentAllocationView1();
        System.out.println("UNBILLED_INSPECTION_ID = " + varInspectionId);
        unbilledItemPaymentsView.setWhereClause("PaymentAllocation.STATUS IS NULL AND ALLOCATION_TYPE_CODE = 'REGULAR' " +
                                                "AND UNBILLED_INSPECTION_ID = " 
                                                + varInspectionId);
        System.out.println(unbilledItemPaymentsView.getWhereClause());
        unbilledItemPaymentsView.executeQuery();
        //grap rows for unbilled view    
        RowSetIterator unbilledItemPaymentsRows = unbilledItemPaymentsView.createRowSetIterator(null);
        unbilledItemPaymentsRows.reset();
        System.out.println("fetchrowcnt ev245: " + unbilledItemPaymentsRows.getFetchedRowCount());
        System.out.println("current index ev2245: " + unbilledItemPaymentsRows.getCurrentRowIndex());
        
        //initiate unitily variables
        Row paymentRow = this.getPaymentView1().getCurrentRow();
        BigDecimal _billedItemsTotal = new BigDecimal(0);
        TReceiptType pType = null;
        String depositSuffix = null;
        //compose deposit slip
        String depositSlip = null;;
        if (paymentType.compareTo("ACCOUNT_TRANSFER") == 0) {
            //getting Deposit Slip Number from DepositTransmittal table
            depositSlip = getDepositSlipNumber();
        } else if(paymentType.compareTo("USB_LOCK_BOX") == 0){
            //getting Deposit Slip Number from DepositTransmittal table
            depositSlip = getDepositSlipNumber();
        }
        else {
            //prepare deposit suffix
            depositSuffix = getDepositSlipSuffix(paymentType);
            depositSlip = getDepositNumber(eventDate, depositSuffix);
        }
        
        //for each unbilled items..
        while (unbilledItemPaymentsRows.hasNext()){
            Row nextItem = unbilledItemPaymentsRows.next();
            //check in unbilled
            setAccountingCodeUsingPafmIdForUnbilled(nextItem);

            oracle.jbo.domain.Number paymentAllocationId =
                (Number)nextItem.getAttribute("PaymentAllocationId");
            System.out.println("paymentAllocationId " + paymentAllocationId);
            //..get allocated amount the an item
            Double allocAmount = nextItem.getAttribute("AllocatedAmount") != null ? ((oracle.jbo.domain.Number) nextItem.getAttribute("AllocatedAmount")).doubleValue():0d;
            //..if allocated amount is not 0 or null, assemble to event data
            if (nextItem.getAttribute("UnbilledItemId") != null && allocAmount > 0 && allocatedItems.containsKey(paymentAllocationId) ){
                
                int it =  ((oracle.jbo.domain.Number)nextItem.getAttribute("UnbilledItemId")).intValue();
                Key itemKey = new Key(new Object[] { it });
                
                //lookup billtypecode for unbilled items
                varBillTypeCode = (String) this.getUnbilledItemsView2().findByKey(itemKey, 1)[0].getAttribute("BillTypeCode");
                String unappliedAgencySourceCode =
                    caloshaUtils.getRegularAgencySourceCode( this.getAgencySourceCode(varBillTypeCode, partyCat, fy.toString()));
                //set the accounting code and remaining evenr details
                cARS245EventDetails.setAccountingCode(unappliedAgencySourceCode,varRevenueSourceCode,varIndex,varFund, varPcaCode);
                
                oracle.jbo.domain.Number val = (oracle.jbo.domain.Number) nextItem.getAttribute("AllocatedAmount");
                oracle.jbo.domain.Number itemId = paymentAllocationId;
                String inspectionNumber = getInspectionNumber((oracle.jbo.domain.Number) nextItem.getAttribute("UnbilledInspectionId"));
                String currentDocument = commonUtils.getDocumentNumber(inspectionNumber, "245", eventDate, itemId.toString());
                String _controlNumber = paymentRow.getAttribute("PaymentControlNumber").toString();
                
                //set the event
                cARS245EventDetails.setEventDetail(val.bigDecimalValue(),
                                                   currentDocument,
                                                   inspectionNumber, 
                                                   eventDate,
                                                   _controlNumber,
                                                   paymentType,
                                                   varBillTypeCode, 
                                                   "OSH",
                                                   depositSlip,
                                                   eventDate);
                List<Object> lstpld = new ArrayList<Object>();
                lstpld.add(cARS245EventDetails.getEvent());
                prepareCARSPacketHeader(currentDocument,username,submitDate,TEventType.CARS_245_EVENT,lstpld);
                try {
                    System.out.println("Sending Unbilled to CARS");
                    Execute_ptClient.invoke(carsPacket); //send the event to CARS
                } catch (Exception e) {
                    e.printStackTrace();
                } 
            }
        }
        unbilledItemPaymentsRows.closeRowSetIterator();
    }

    /**
     * Helper method to get deposit slip number suffix given the payment type.
     * @return deposit slip number suffix
     * @param paymentType 
     */ 
    private String getDepositSlipSuffix(String paymentType) {
        TReceiptType pType;
        String depositSuffix = null;
        if (paymentType.equals("VISA_MASTER_CREDIT_CARD")){
            pType = TReceiptType.VISA_MASTER_CREDIT_CARD;
            depositSuffix = "01";
        }else if (paymentType.equals("AMEX_CREDIT_CARD")){
            pType = TReceiptType.AMEX_CREDIT_CARD;
            depositSuffix = "02";
        }else if (paymentType.equals("DISCOVER_CREDIT_CARD")){
            pType = TReceiptType.DISCOVER_CREDIT_CARD;
            depositSuffix = "03";
        }else if (paymentType.equals("EFT")){
                    pType = TReceiptType.EFT;
                    depositSuffix = "04";
        }else if (paymentType.equals("ACCOUNT_TRANSFER")){
                            pType = TReceiptType.ACCOUNT_TRANSFER;
                            depositSuffix = "05";
                        }
        return depositSuffix;
    }
    
    /**
     * Helper method to get TRecieptType Enum given the payment type.
     * @return TRecieptType deposit slip number suffix
     * @param paymentType 
     */ 
    private TReceiptType getPaymentType(String paymentType) {
        TReceiptType pType = null;
        String depositSuffix = null;
        if (paymentType.equals("VISA_MASTER_CREDIT_CARD")){
            pType = TReceiptType.VISA_MASTER_CREDIT_CARD;
           
        }else if (paymentType.equals("AMEX_CREDIT_CARD")){
            pType = TReceiptType.AMEX_CREDIT_CARD;
           
        }else if (paymentType.equals("DISCOVER_CREDIT_CARD")){
            pType = TReceiptType.DISCOVER_CREDIT_CARD;
           
        } else if (paymentType.equals("EFT")){
                    pType = TReceiptType.EFT;
                   
        }else if (paymentType.equals("ACCOUNT_TRANSFER")){
                    pType = TReceiptType.ACCOUNT_TRANSFER;
        }
        return pType;
    }

    /**
     * Prepares the main header information for the Event packet.
     */   
    private void prepareCARSPacketHeader(String varCurrentDocument,String username,
                                                     GregorianCalendar submitDate, TEventType eventType, List<Object> payloadList){
        carsPacket.setPacketHeader("WS", "CARS", varCurrentDocument, "CALOSHA","CALOSHA-AR", "DEV", username, submitDate);
        carsPacket.setPacketPayloadInformation(eventType);
        carsPacket.setPacketPayload(payloadList);
    }
    
    /**
     * Helper method to assemble and format the deposit number using deposit date and payment type
     * @return deposit number
     * @param aDate, paymentType 
     */ 
    private String getDepositNumber(GregorianCalendar aDate, String paymentType){
        StringBuilder formattedDepositNumber = new StringBuilder();
        String year = String.valueOf(aDate.get(Calendar.YEAR)).substring(2, 4);
        formattedDepositNumber.append("ZB");
        formattedDepositNumber.append(year);
        formattedDepositNumber.append(getMonthDayPrefix(aDate.get(Calendar.MONTH) + 1));
        formattedDepositNumber.append(getMonthDayPrefix(aDate.get(Calendar.DATE))); 
        formattedDepositNumber.append(paymentType);
        return formattedDepositNumber.toString();
    }
    
    /**
     * Helper method to append 0 prefix to 1 digit date.
     * @return 2 digit day or month
     * @param inputNumber - the day or month digit
     */ 
    private String getMonthDayPrefix(int inputNumber) {
        StringBuilder value = new StringBuilder();
        // if one digit, append 0 prefix
        if (inputNumber > 0 && inputNumber <= 9) {
            value.append("0").append(inputNumber);
        } else {
            value.append(inputNumber);
        }
        
        return value.toString();
    }

    /**
     * Container's getter for PartyAgencyFundMapView1.
     * @return PartyAgencyFundMapView1
     */
    public ViewObjectImpl getPartyAgencyFundMapView1() {
        return (ViewObjectImpl)findViewObject("PartyAgencyFundMapView1");
    }

    /**
     * Sets unappliedUnbilledItemId attribute
     * @param unappliedUnbilledItemId 
     */ 
    public void setUnappliedUnbilledItemId(oracle.jbo.domain.Number unappliedUnbilledItemId) {
        this.unappliedUnbilledItemId = unappliedUnbilledItemId;
    }

    /**
     * Gets unappliedUnbilledItemId attribute
     * @return unappliedUnbilledItemId 
     */ 
    public oracle.jbo.domain.Number  getUnappliedUnbilledItemId() {
        return unappliedUnbilledItemId;
    }

    /**
     * Method to populate Payment Allocation table with Unbilled items.
     */ 
    public void processUnbilledPayment() {
        ViewObjectImpl unbilledItemsPayment = this.getUnbilledItemsView1();
        ViewObjectImpl paymentAllocation = this.getPaymentAllocationView1();
        RowSetIterator unbilledItemsPaymentIter =
            unbilledItemsPayment.createRowSetIterator(null);
        unbilledItemsPaymentIter.reset();
        //for each unbilled item assign appropriate keys and allocated amount
        while (unbilledItemsPaymentIter.hasNext()) {
            Row unbilledRow = unbilledItemsPaymentIter.next();
            if (unbilledRow.getAttribute("AllocatedAmount") != null) {
                if (((oracle.jbo.domain.Number)unbilledRow.getAttribute("AllocatedAmount")).doubleValue() >
                    0) {   
                    System.out.println("Unbilled Allocted Amount " + ((oracle.jbo.domain.Number)unbilledRow.getAttribute("AllocatedAmount")).doubleValue() );
                    Row paymentAllocRow = paymentAllocation.createRow();                                                                            
                    paymentAllocRow.setAttribute("UnbilledInspectionId", (oracle.jbo.domain.Number)unbilledRow.getAttribute("InspectionId"));
                    paymentAllocRow.setAttribute("UnbilledItemId", (oracle.jbo.domain.Number) unbilledRow.getAttribute("UnbilledItemId"));
                    paymentAllocRow.setAttribute("PaymentId",  this.getPaymentId());
                    paymentAllocRow.setAttribute("AllocatedAmount", ((oracle.jbo.domain.Number)unbilledRow.getAttribute("AllocatedAmount")).round(2) );
                    oracle.jbo.domain.Number paymentAllocationId = getPaymentAllocationIdSequence();
                    paymentAllocRow.setAttribute("PaymentAllocationId", paymentAllocationId);
                    if (varReferenceNumber != null){
                        paymentAllocRow.setAttribute("ReferenceNumber", varReferenceNumber);
                    }
                    allocatedItems.put(paymentAllocationId,
                                       (oracle.jbo.domain.Number)unbilledRow.getAttribute("InspectionId"));
                }
            }

        }
        unbilledItemsPaymentIter.closeRowSetIterator(); // close iterator

    }
    
    /**
     * Method to populate Payment Allocation table with Billed items. This method also applies payments to Payment_Plan items via the Payment_Plan_Allocation table.
     */ 
    public void processBilledPayment() {
        ViewObjectImpl billedItemsPayment = this.getBilledItemsView1();
        ViewObjectImpl paymentAllocation = this.getPaymentAllocationView1();
        ViewObjectImpl paymentPlanAllocationVo = this.getPaymentPlanAllocationView1();
        ViewObjectImpl paymentPlanItemBalanceVo = this.getPaymentPlanItemBalanceView1();
        RowSetIterator paymentPlanItemBalanceIter = paymentPlanItemBalanceVo.getRowSetIterator();
        RowSetIterator billedItemsPaymentIter =
            billedItemsPayment.createRowSetIterator(null);
        billedItemsPaymentIter.reset();
        //holds remaining bals of current ppitem if any, establish the first allocatable pplan item.
        Number currPPlanRemainingAmount = calculateCurrPPlanItemRemainingAmount(paymentPlanItemBalanceIter); 
        //for each unbilled item assign appropriate keys and allocated amount
        while (billedItemsPaymentIter.hasNext()) {
            Row billedRow = billedItemsPaymentIter.next();
            //if allocated amount has value greater than zero, process it
            if (billedRow.getAttribute("AllocatedAmount") != null) {
                if (((oracle.jbo.domain.Number)billedRow.getAttribute("AllocatedAmount")).doubleValue() > 0) {
                    Number allocatableAmount = (oracle.jbo.domain.Number)billedRow.getAttribute("AllocatedAmount");
                    System.out.println("Billed Allocted Amount " + (allocatableAmount).doubleValue());
                    Row paymentAllocRow = paymentAllocation.createRow();  
                    paymentAllocRow.setAttribute("CitationId", (oracle.jbo.domain.Number) billedRow.getAttribute("CitationId"));
                    paymentAllocRow.setAttribute("CitationItemId", (oracle.jbo.domain.Number) billedRow.getAttribute("CitationItemId"));
                    paymentAllocRow.setAttribute("InspectionId", (oracle.jbo.domain.Number)billedRow.getAttribute("InspectionId"));
                    paymentAllocRow.setAttribute("PaymentId",  this.getPaymentId());
                    paymentAllocRow.setAttribute("AllocatedAmount", ((oracle.jbo.domain.Number) billedRow.getAttribute("AllocatedAmount")).round(2) );
                    oracle.jbo.domain.Number paymentAllocationId = getPaymentAllocationIdSequence();
                    paymentAllocRow.setAttribute("PaymentAllocationId", paymentAllocationId);
                    allocatedItems.put(paymentAllocationId,
                                       (oracle.jbo.domain.Number)billedRow.getAttribute("InspectionId"));
                    
                    //allocate to payment plan items and get the current pplan item's balance
                    currPPlanRemainingAmount = this.allocatePaymentPlan(paymentPlanAllocationVo, paymentPlanItemBalanceIter  ,paymentAllocationId, allocatableAmount, currPPlanRemainingAmount);
                }
            }
        }
        //close iterators
        billedItemsPaymentIter.closeRowSetIterator();
        paymentPlanItemBalanceIter.closeRowSetIterator();

    }
    
    /**
     * Calculates the current outstanding amount of the earliest unpaid or partially paid item 
     * @return balance or 0 if no payment plan item carries balance
     **/
    private Number calculateCurrPPlanItemRemainingAmount(RowSetIterator paymentPlanItemBalanceIter){
        while (paymentPlanItemBalanceIter.hasNext()){
            Row paymentPlanItemBalanceRow = paymentPlanItemBalanceIter.next();
            Number bals = ((Number)paymentPlanItemBalanceRow.getAttribute("Balance"));
            if (bals != null && bals.getValue() != 0){
                return bals;
            }
        }
        return new Number(0);
    }

    /**
     * Allocates to payment plan items and returns the unallocated amount.
     * @return balance of the last pplan item allocated
     **/    
    public Number allocatePaymentPlan(ViewObjectImpl paymentPlanAllocationVo,RowSetIterator paymentPlanItemBalanceIter,Number paymentAllocationId, Number amountAllocted, Number currPPlanRemainingAmount){
        Number amtAlloc = amountAllocted;
        Number ppBals = new Number(0);
        //Find the first item that carries a balance and make it he starting point for the allocation  
        while (paymentPlanItemBalanceIter.hasNext()) {
            Row paymentPlanItemBalance = null;
            if (currPPlanRemainingAmount.getValue() > 0) {//if previous ppitem has remaining balance then use that pp item
                paymentPlanItemBalance = paymentPlanItemBalanceIter.getCurrentRow();
                System.out.println("currentRow " + paymentPlanItemBalance.getAttribute("PaymentPlanDetailId"));
                ppBals = currPPlanRemainingAmount;
                currPPlanRemainingAmount = new Number(0);
            } else {//otherwise, get next ppitem
                 paymentPlanItemBalance = paymentPlanItemBalanceIter.next(); 
                ppBals = (Number)paymentPlanItemBalance.getAttribute("AmountDue");
                System.out.println("nextRow ");
            }
            
            //if current pplan item is partially paid
             if (ppBals.getValue() > 0){
                 //..and payment amount does not cover entire pplan item balance 
                if (ppBals.getValue() > amtAlloc.getValue()){
                    //..create row payment_plan_allocation
                    Row newPaymentPlanAlloction = paymentPlanAllocationVo.createRow();
                    newPaymentPlanAlloction.setAttribute("PaymentPlanDetailId", paymentPlanItemBalance.getAttribute("PaymentPlanDetailId"));
                    newPaymentPlanAlloction.setAttribute("PaymentAllocationId", paymentAllocationId);                  
                    //..then decrease balance by the amount allocated.
                    ppBals = ppBals.subtract(amtAlloc);
                    //..then update allocatable amount (should be 0 at this point)
                    amtAlloc = amtAlloc.subtract(amtAlloc);
                    System.out.println( "a* " +paymentPlanItemBalance.getAttribute("InstallmentNumber") +" " + paymentPlanItemBalance.getAttribute("PaymentPlanDetailId") + " " + paymentAllocationId + " _amtAlloc: " +amtAlloc+" _ppBals: "+ppBals);
                }else 
                    //..and there is more payment amount than the pplan item balance
                    if(ppBals.getValue() <= amtAlloc.getValue()){
                    //..create row payment_plan_allocation
                    Row newPaymentPlanAlloction = paymentPlanAllocationVo.createRow();
                    newPaymentPlanAlloction.setAttribute("PaymentPlanDetailId", paymentPlanItemBalance.getAttribute("PaymentPlanDetailId"));
                    newPaymentPlanAlloction.setAttribute("PaymentAllocationId", paymentAllocationId);
                    //..then get extra allocatable amount.
                    amtAlloc = amtAlloc.subtract(ppBals);
                    System.out.println("b* " +paymentPlanItemBalance.getAttribute("InstallmentNumber") +" " + paymentPlanItemBalance.getAttribute("PaymentPlanDetailId") + " " + paymentAllocationId + " _amtAlloc: " +amtAlloc+" _ppBals: "+ppBals);
                }
                
            }
            if (amtAlloc.getValue() <= 0){
                System.out.println( "break -- nothing left to allocate "); 
                return ppBals; //exit if nothing more to allocate
                
            }
        }
        //return last pplan item's balance.
        return ppBals;
    }

    /**
     * Gets the value of paymentId attribute
     * @return paymentId 
     */ 
    public Number getPaymentId() {
        return paymentId;
    }
    
    /**
     * Commits trasaction and resets the isNotCommited flag.
     */     
    public void commitProcessPayment(){
        isNotCommited = false;
        this.getDBTransaction().commit();
    }
    
    /**
     * Client method to initiate payment processing by clients using this Application Module
     */

    public void processPayments() {
        Number unbilledAmount;
        //init allocatedItems if null 
        if (allocatedItems == null) {
            allocatedItems = new  HashMap<oracle.jbo.domain.Number,oracle.jbo.domain.Number >();
        }
        //if unapplied amount exist, create record
        if ((oracle.jbo.domain.Number) this.getPaymentView1().getCurrentRow().getAttribute("UnappliedAmount") != null) {
            unbilledAmount = (oracle.jbo.domain.Number)  this.getPaymentView1().getCurrentRow().getAttribute("UnappliedAmount");
            if (unbilledAmount.doubleValue() > 0){
                //oracle.jbo.domain.Number unappliedAmount1 = null;
                //unappliedAmount1 = (oracle.jbo.domain.Number) this.getPaymentView1().getCurrentRow().getAttribute("UnappliedAmount");
                createUnappliedUnbilledItem(unbilledAmount, "UNAPPLIED");
            }
        }
        //process Unapplied items
        ViewObjectImpl paymentView = this.getPaymentView1();
        oracle.jbo.domain.Number paymentUnappliedAmt = (Number)((oracle.jbo.domain.Number) paymentView.getCurrentRow().getAttribute("UnappliedAmount")).round(2);
        this.createUnappliedPaymentAllocation(paymentUnappliedAmt);
        
        //process Billed items
        this.processBilledPayment();
        
        //process Unbilled items
        this.processUnbilledPayment();
        
        //if Post Judgment Interest exist, create record
        unbilledAmount = null;
        if ((oracle.jbo.domain.Number) this.getPaymentView1().getCurrentRow().getAttribute("PostJudgmentInterest") != null) {
            unbilledAmount = (oracle.jbo.domain.Number)  this.getPaymentView1().getCurrentRow().getAttribute("PostJudgmentInterest");
            if (unbilledAmount.doubleValue() > 0){
                //oracle.jbo.domain.Number unappliedAmount1 = null;
                //unappliedAmount1 = (oracle.jbo.domain.Number) this.getPaymentView1().getCurrentRow().getAttribute("UnappliedAmount");
                createUnappliedUnbilledItem(unbilledAmount, "UNBILLED_POST_JUDGMNT_INT");
            }
        }

        //for shared transaction, no need to create related party
        // create related party entry for payment
        if (!isPaymentExist) {
            this.createRelatedParty(this.getPaymentId());    
        }
       
        //process Post Judgment Interest
        try{
            
            //test if postjudgmentinterest is null
            oracle.jbo.domain.Number paymentPostJudgment;
            if (paymentView.getCurrentRow().getAttribute("PostJudgmentInterest") != null)
                paymentPostJudgment = (Number)((oracle.jbo.domain.Number) paymentView.getCurrentRow().getAttribute("PostJudgmentInterest")).round(2);
            else 
                paymentPostJudgment = new Number("0");
            
            this.createUnappliedPaymentAllocation(paymentPostJudgment);

            //create tpc referral 
            String paymentType = (String) paymentView.getCurrentRow().getAttribute("PaymentTypeCode");
            if (paymentType.compareToIgnoreCase("Account_Transfer")!=0){//if payment type is not Account Tranfer then refer to EDD
                this.createTpcReferral();
            }
        }
        catch(Exception e ){
            e.printStackTrace();
        }        
        

    }

    /**
     * Allocates to payment plan items and returns the unallocated amount.
     * @return balance of the last pplan item allocated
     **/    
    public void setIsPaymentExist(boolean isPaymentExist) {
        this.isPaymentExist = isPaymentExist;
    }
    
    /**
     * Utility method that refreshes Payment Allocation View Objects.
     */
    public void refreshAllocationTables(){
        this.getUnbilledItemsView1().executeQuery();
        this.getBilledItemsView1().executeQuery();
    }
    
    /**
     * Client method to allocatePaymentAmount to allocatable billed and unbilled items.
     */
    public void allocatePaymentAmount() {

        //this.getUnappliedAmount().setValue(0);
        ViewObjectImpl paymentView = this.getPaymentView1();
        
        Row paymentCurrentRow = paymentView.getCurrentRow();
        Double allocatableAmount = ((oracle.jbo.domain.Number)paymentCurrentRow.getAttribute("PaymentAmount")).doubleValue();
        Double remainingAmount;
        
        allocatableAmount = getAllocatableAmountForTPCReferredInvoice(paymentCurrentRow, allocatableAmount);        
         
        //RowSetIterator iteratorBinding =  dcBindingContainer.findIteratorBinding("UnbilledItemsView1Iterator");
        RowSetIterator unbilledRowIter = this.getUnbilledItemsView1().createRowSetIterator(null);
        resetAlloctions(unbilledRowIter);
        remainingAmount = allocateToInvoiceItems(unbilledRowIter, allocatableAmount, "UNBILLED");
        
       // DCIteratorBinding iteratorBinding2 = dcBindingContainer.findIteratorBinding("BilledItemsView1Iterator");
        RowSetIterator billedRowIter = this.getBilledItemsView1().createRowSetIterator(null);
        resetAlloctions(billedRowIter);
        remainingAmount = allocateToInvoiceItems(billedRowIter, remainingAmount, "BILLED");

        //dont show if negative value
        try {
            paymentCurrentRow.setAttribute("UnappliedAmount",new oracle.jbo.domain.Number(remainingAmount > 0 ? remainingAmount : 0));
            System.out.println("UnappliedAmount " + paymentCurrentRow.getAttribute("UnappliedAmount"));
        } catch (SQLException e) {
        }
        //close iterators
        //unbilledRowIter.closeRowSetIterator();
        //billedRowIter.closeRowSetIterator();
    }

    /** 
     * Client method to recalculate Unapplied Amount when manual allocation is done.
     */
    public void recalculateUnappliedAfterManualAllocation(){
        ViewObjectImpl paymentView = this.getPaymentView1();
        
        Row paymentCurrentRow = paymentView.getCurrentRow();
        
        Double allocatableAmount = ((oracle.jbo.domain.Number)paymentCurrentRow.getAttribute("PaymentAmount")).doubleValue();        
        allocatableAmount = getAllocatableAmountForTPCReferredInvoice(paymentCurrentRow, allocatableAmount); 
        
        RowSetIterator unbilledRowIter = this.getUnbilledItemsView1().createRowSetIterator(null);
        RowSetIterator billedRowIter = this.getBilledItemsView1().createRowSetIterator(null);
        
        Double remainingAmount = allocatableAmount - (getManuallyAllocatedAmount(unbilledRowIter) + getManuallyAllocatedAmount(billedRowIter));
        
        //dont show if negative value
        try {
            paymentCurrentRow.setAttribute("UnappliedAmount",new oracle.jbo.domain.Number(remainingAmount > 0 ? remainingAmount : 0));
            System.out.println("UnappliedAmount " + paymentCurrentRow.getAttribute("UnappliedAmount"));
        } catch (SQLException e) {
        }
        //close iterators
        unbilledRowIter.closeRowSetIterator();
        billedRowIter.closeRowSetIterator();

    }

    /** Helper method that returns that allocation to billed or unbilled items.
     *  @param itemRowIter
     *  @return allocated total amount
     */
    private Double getManuallyAllocatedAmount(RowSetIterator itemRowIter) {
        Double allocatedTotalAmount = 0d;
        while (itemRowIter.hasNext()){
            Row unbilledRow = itemRowIter.next();
            Number allocAmount =  (Number) (unbilledRow.getAttribute("AllocatedAmount") != null ? unbilledRow.getAttribute("AllocatedAmount") : new Number(0) );
            allocatedTotalAmount = allocatedTotalAmount + (allocAmount).doubleValue();
        }
        return allocatedTotalAmount;
    }

    /**
     * Helper method to calculate allocatable amount for TPC referred invoice depending on the type of payment being allocated.
     * @param paymentCurrentRow, allocableAmount
     * @return
     */
    private Double getAllocatableAmountForTPCReferredInvoice(Row paymentCurrentRow,
                                                             Double allocatableAmount) {
        //get PostJudgmentInterest amount and subtract to allocatable payment amount
        oracle.jbo.domain.Number postJudgmentInterest = (oracle.jbo.domain.Number)paymentCurrentRow.getAttribute("PostJudgmentInterest");
        String paymentTypeCode = (String)paymentCurrentRow.getAttribute("PaymentTypeCode");

        if (postJudgmentInterest != null){
            System.out.println("calculated allocatable amount with post judgment interest");
            allocatableAmount = allocatableAmount - postJudgmentInterest.doubleValue();
        }
        
        //test for tpc referred invoice, if so no allocatable regular payment amount should be done except for Account_Transfer type payments
        Row currentInvoiceRow = this.getInspectionInformationView1().getCurrentRow();
        String invoiceNumber =currentInvoiceRow.getAttribute("InspectionNumber") != null ? (String) currentInvoiceRow.getAttribute("InspectionNumber") : "";
        
        //set allocatable amount to 0 if invoice is EDD Referred and payment is not Account_Transfer
        //if (isTPCReferred(invoiceNumber) && paymentTypeCode.compareToIgnoreCase("ACCOUNT_TRANSFER")!=0){
            System.out.println("calculated allocatable amount for tpcReferred invoice");
            //allocatableAmount = 0d;
        //}
        return allocatableAmount;
    }
    
    /**
     * Client method to allocatePaymentAmount to allocatable billed and unbilled items given a Payment Amount.
     * @param paymentAmount
     */    
    public void allocatePaymentAmount(Double paymentAmount) {
        ViewObjectImpl paymentView = this.getPaymentView1();
        Row paymentCurrentRow = paymentView.getCurrentRow();
        
        //recalculate allocatable amount for TPC Referred invoices
        Double allocatableAmount = getAllocatableAmountForTPCReferredInvoice(paymentCurrentRow, paymentAmount); 
        
        Double remainingAmount;
        
        RowSetIterator unbilledRowIter = this.getUnbilledItemsView1().getRowSetIterator();
        resetAlloctions(unbilledRowIter); //reset unbilled iters
        remainingAmount = allocateToInvoiceItems(unbilledRowIter, allocatableAmount, "UNBILLED");
        RowSetIterator billedRowIter = this.getBilledItemsView1().getRowSetIterator();
        resetAlloctions(billedRowIter); //reset billed iters
        remainingAmount = allocateToInvoiceItems(billedRowIter, remainingAmount, "BILLED");

        //dont show if negative value
        try {
            paymentCurrentRow.setAttribute("UnappliedAmount",new oracle.jbo.domain.Number(remainingAmount > 0 ? remainingAmount : 0));
            System.out.println("UnappliedAmount " + paymentCurrentRow.getAttribute("UnappliedAmount"));
        } catch (SQLException e) {
        }
        //close iterators
        unbilledRowIter.closeRowSetIterator();
        billedRowIter.closeRowSetIterator();
    }

    /**
     * Helper method to allocate payments to allocatable invoice items depending on the itemType.
     * @return remaining allocatable amount
     * @param invoiceItemsIter, paymentAmount, itemType 
     */
    private Double allocateToInvoiceItems(RowSetIterator invoiceItemsIter,
                                          Double paymentAmount, String itemType) {
        invoiceItemsIter.reset();
        //for each invoice item that carries a balance
        while (paymentAmount >= 0 && invoiceItemsIter.hasNext()){
            Row next = invoiceItemsIter.next();
            oracle.jbo.domain.Number bals = (oracle.jbo.domain.Number) next.getAttribute("Balance");
            //if bals is less than remaining available amount, entire payment amount 
            if (!(bals.compareTo(paymentAmount) == -1)) {
                try {
                    next.setAttribute("AllocatedAmount", new oracle.jbo.domain.Number(paymentAmount)); 
                } catch (SQLException e) {
                }
            } else //else if bals is greater than payment amount, apply same amount as bals
            if (!(bals.compareTo(paymentAmount) == 1)){ 
                next.setAttribute("AllocatedAmount", bals);
            //otherwise apply none
            } else{ 
                next.setAttribute("AllocatedAmount", null); 
            }
            next.setAttribute("ItemType",itemType);
            
            //decrement allocatable payment amount
            paymentAmount -= bals.doubleValue();
        }
        return paymentAmount;
    }
    
    /**
     * Helper method to reset given iterators.
     * @param rowIterator
     */    
    private void resetAlloctions(RowSetIterator rowIterator){
        rowIterator.reset();
        while (rowIterator.hasNext()){
            Row next = rowIterator.next();
                next.setAttribute("AllocatedAmount", 0);
        }   
    }
    
    /**
     * Client method to undo payment allocations.
     */
    public void undoPaymentAllocations(){
        ViewObjectImpl paymentView = this.getPaymentView1();
        Row paymentCurrentRow = paymentView.getCurrentRow();
        //reset current row amount to 0 to prevent npe
        if (paymentCurrentRow.getAttribute("PaymentAmount") != null){
            Double paymentAmount = ((oracle.jbo.domain.Number)paymentCurrentRow.getAttribute("PaymentAmount")).doubleValue();
        } else {
            Double paymentAmount = new Double(0);
        }
        //reset all
        Double remainingAmount;
        RowSetIterator unbilledRowIter = this.getUnbilledItemsView1().getRowSetIterator();
        removeRows(unbilledRowIter);
        RowSetIterator billedRowIter = this.getBilledItemsView1().getRowSetIterator();
        removeRows(billedRowIter);
        paymentCurrentRow.setAttribute("UnappliedAmount",null);
        System.out.println("Undo UnappliedAmount " + paymentCurrentRow.getAttribute("UnappliedAmount"));

        unbilledRowIter.closeRowSetIterator();
        billedRowIter.closeRowSetIterator();
    }
    
    /**
     * Helper method to remove all rows from a given RowSetIterator.
     * @param rowIterator
     */
    private void removeRows(RowSetIterator rowIterator){
        rowIterator.reset();
        System.out.println("Before remove " +rowIterator.getRowCount());
        while (rowIterator.hasNext()){
            Row next = rowIterator.next();
            System.out.println("Removing Item with amount " +next.getAttribute("AllocatedAmount"));
                next.remove();
        }   
        System.out.println("After remove " +rowIterator.getRowCount());
    }

    /**
     * Calls beforeCommit method.
     */
    @Override
    public void beforeCommit(TransactionEvent transactionEvent) {      
        super.beforeCommit(transactionEvent);
        
    }

    /**
     * Helper method that populates the hashmap that associates payment allocation amount to payment allocation items to be used for downstream processing.
     */
    private void populateAllocatedItemCollection() {
        allocatedItems = new  HashMap<oracle.jbo.domain.Number,oracle.jbo.domain.Number >();
        RowSetIterator unbilledRows =
            this.getPaymentAllocationView4().createRowSetIterator(null);
        unbilledRows.reset();
        
        //add each unbilled payments to hash
        while (unbilledRows.hasNext()) {
            Row next = unbilledRows.next();
            allocatedItems.put((oracle.jbo.domain.Number)next.getAttribute("PaymentAllocationId"),
                               (oracle.jbo.domain.Number)next.getAttribute("AllocatedAmount"));
        }

        RowSetIterator billedRows =
            this.getPaymentAllocationView3().createRowSetIterator(null);
        billedRows.reset();
        
        //add each billed payments to hash
        while (billedRows.hasNext()) {
            Row next = billedRows.next();
            allocatedItems.put((oracle.jbo.domain.Number)next.getAttribute("PaymentAllocationId"),
                               (oracle.jbo.domain.Number)next.getAttribute("AllocatedAmount"));
        }
        System.out.println("hastable size " + allocatedItems.size());
    }


    /**
     * Container's getter for DepositTransmittalView1.
     * @return DepositTransmittalView1
     */
    public ViewObjectImpl getDepositTransmittalView1() {
        return (ViewObjectImpl)findViewObject("DepositTransmittalView1");
    }


    /**
     * Container's getter for PaymentView1.
     * @return PaymentView1
     */
    public ViewObjectImpl getPaymentView1() {
        return (ViewObjectImpl)findViewObject("PaymentView1");
    }


    /**
     * Container's getter for RelatedPartyView1.
     * @return RelatedPartyView1
     */
    public ViewObjectImpl getRelatedPartyView1() {
        return (ViewObjectImpl)findViewObject("RelatedPartyView1");
    }

    /**
     * Container's getter for PaymentRelatedPartyLink1.
     * @return PaymentRelatedPartyLink1
     */
    public ViewLinkImpl getPaymentRelatedPartyLink1() {
        return (ViewLinkImpl)findViewLink("PaymentRelatedPartyLink1");
    }
    
    /**
     * Find or create deposit transmittal and returns Id
     * @param depositSlipNumber
     * @param transmittalDate
     * @return
     */
    public oracle.jbo.domain.Number ifCreateDepositTransmittal(String depositSlipNumber, Date transmittalDate, String paymentType){
        // stop if payment is check or edf    
        if (paymentType.compareTo("CHECK") == 0 || paymentType.compareTo("EDF") == 0){
            return null;
        }
        
        //store number for use later
        this.depositSlipNumber = depositSlipNumber;
        
        ViewObjectImpl depositTransmittalView = this.getDepositTransmittalView1();
        VariableImpl _depslip = new VariableImpl();
        _depslip.setName("depositSlip");
        
        //get rows directly from database table
        RowIterator depositTransmittalIter = depositTransmittalView.findByViewCriteriaWithBindVars(this.getDepositTransmittalView1().getViewCriteria("DepositTransmittalViewCriteria"), -1, getDepositTransmittalView1().QUERY_MODE_SCAN_DATABASE_TABLES, new Variable[]{_depslip}, new Object[] {depositSlipNumber});
        //get first row if it exist otherwise create a new one
        if (depositTransmittalIter.hasNext()){
            Row depositTransmittalRow = depositTransmittalIter.next();
            depositTransmittalId =  (oracle.jbo.domain.Number) depositTransmittalRow.getAttribute("DepositTransmittalId");
        } else {
            Row _newRow = depositTransmittalView.createRow();
            _newRow.setAttribute("DepositSlipNumber", depositSlipNumber);
            _newRow.setAttribute("TransmittalDate", transmittalDate);
            depositTransmittalId = this.getDepositTransmittalIdSequence();
            _newRow.setAttribute("DepositTransmittalId", depositTransmittalId);
        }
        
        //assign deposittransmittalid to payment
        ViewObjectImpl paymentView = this.getPaymentView1();
        Row paymentViewRow = paymentView.getCurrentRow();
        paymentViewRow.setAttribute("DepositTransmittalId", depositTransmittalId);
        return depositTransmittalId;     
    }

    
    @Override
    /**
     * Utility method that saves the allocatedItems hash object to persist beyond a user Request.
     */
    protected void passivateState(Document doc, Element parent) {

        super.passivateState(doc, parent);
        ByteArrayOutputStream byteArrayOutputStream =
            new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream;
        try {
            objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
            objectOutputStream.writeObject(allocatedItems);
        } catch (IOException e) {
        }
        String stringifiedValue = byteArrayOutputStream.toString();
        // Add them to the XML
        Node nodeUserData = doc.createElement("USERDATA");
        Element elem = doc.createElement("PAYMENT_PROC_ALLOC_ITEM");
        elem.setAttribute("VALUE", stringifiedValue);
        elem.setAttribute("TYPE", "java.lang.Object");
        nodeUserData.appendChild(elem);
        parent.appendChild(nodeUserData);
        //System.out.println("Passivated hashtable " + allocatedItems.toString());
    }

    @Override
    /**
     * Utility method that retrieves a passavated allocatedItems hash object
     */
    protected void activateState(Element parent) {
        
        if (parent != null) {
            NodeList nl = parent.getElementsByTagName("USERDATA");
            if (nl.getLength() > 0) {

                Node n = nl.item(0);
                NodeList nl2 = n.getChildNodes();
                ByteArrayInputStream byteArrayInputStream = null;
                ObjectInputStream objectInputStream = null;
                for (int i = 0; i < nl2.getLength(); i++) {

                    Element element = (Element)nl2.item(i);
                    try {
                        byte[] obj = element.getAttribute("VALUE").getBytes();

                        byteArrayInputStream = new ByteArrayInputStream(obj);

                        try {
                            objectInputStream =
                                    new ObjectInputStream(byteArrayInputStream);
                        } catch (IOException e) {
                        }

                        this.allocatedItems =
                                (HashMap<oracle.jbo.domain.Number, oracle.jbo.domain.Number>)objectInputStream.readObject();
                        objectInputStream.close();

                    } catch (Exception ex) {
                        ex.printStackTrace();
                    }
                }

            }
        }
        //System.out.println("Activated hashtable " + allocatedItems.toString());
        super.activateState(parent);

    }

    /**
     * Gets getAllocatedItems attribute.
     * @return 
     */
    public Map<oracle.jbo.domain.Number,oracle.jbo.domain.Number > getAllocatedItems() {
        return allocatedItems;
    }

    /**
     * Set the allocated items collection
     * @param inAllocatedItems
     */
    public void setAllocatedItems(Map<oracle.jbo.domain.Number,oracle.jbo.domain.Number > inAllocatedItems) {
        //append to existing allocated items
        if (allocatedItems != null){
            this.allocatedItems.putAll((HashMap<oracle.jbo.domain.Number,oracle.jbo.domain.Number >) inAllocatedItems);
        }
        this.allocatedItems = (HashMap<oracle.jbo.domain.Number,oracle.jbo.domain.Number >) inAllocatedItems;
    }

    /**
     * Container's getter for InspectionInformationView2.
     * @return InspectionInformationView2
     */
    public ViewObjectImpl getInspectionInformationView2() {
        return (ViewObjectImpl)findViewObject("InspectionInformationView2");
    }

    /**
     * Utility method to get the Inspection Number given an InspectionId
     * @return Inspection Number
     * @param inspectionId
     */    
    private String getInspectionNumber(oracle.jbo.domain.Number inspectionId){
        String ret  = null;
        int it =  inspectionId.intValue();
        Key itemKey = new Key(new Object[] { it });
        ret =  getInspectionInformationView2().findByKey(itemKey, 1)[0].getAttribute("InspectionNumber").toString();
        return ret;
    }

    /**
     * Container's getter for UnbilledItemsView2.
     * @return UnbilledItemsView2
     */
    public ViewObjectImpl getUnbilledItemsView2() {
        return (ViewObjectImpl)findViewObject("UnbilledItemsView2");
    }
    
    /**
     * Returns party agency fund map id give the params
     * @param billType
     * @param partyCategory
     * @param fiscalYear
     * @return
     */
    private String getAgencySourceCode(String billType, String partyCategory, String fiscalYear){
        String ret = null;
        
        ViewObjectImpl pafmView = this.getPartyAgencyFundMapView1();
        VariableImpl _partyCategoryBind = new VariableImpl();
        _partyCategoryBind.setName("partyCategory");
        VariableImpl _billTypeCodeBind = new VariableImpl();
        _billTypeCodeBind.setName("billTypeCode");
        VariableImpl _fy = new VariableImpl();
        _fy.setName("fiscalYear");
        
        //get values directly from database tables 
        RowIterator pafmRowIter = pafmView.findByViewCriteriaWithBindVars(pafmView.getViewCriteria("PartyCategoryViewCriteria"), -1, pafmView.QUERY_MODE_SCAN_DATABASE_TABLES, new Variable[]{_partyCategoryBind, _billTypeCodeBind, _fy}, new Object[] {partyCategory,billType,fiscalYear});
        oracle.jbo.domain.Number _pafmId = null;
        //get value from first row
        if (pafmRowIter.hasNext()){
            Row pafmRow =pafmRowIter.next();
            ret = (String) pafmRow.getAttribute("AgencySourceCode");
        }
        return ret;
    }
    
    /**
     * Get partyCategoryCode of the current Inspection.
     * @return partyCategoryCode
     */
    private String getPartyCategory(){
        String ret = null;
        ViewObjectImpl inspectionInformationView = this.getInspectionInformationView1();
        Row currentInvoiceRow = this.getInspectionInformationView1().getCurrentRow();
        ret = (String) currentInvoiceRow.getAttribute("PartyCategoryCode");
        return ret;
    }


    /**
     * Container's getter for BilledItemsView2.
     * @return BilledItemsView2
     */
    public ViewObjectImpl getBilledItemsView2() {
        return (ViewObjectImpl)findViewObject("BilledItemsView2");
    }


    /**
     * Container's getter for PaymentPlanAllocationView1.
     * @return PaymentPlanAllocationView1
     */
    public ViewObjectImpl getPaymentPlanAllocationView1() {
        return (ViewObjectImpl)findViewObject("PaymentPlanAllocationView1");
    }

    /**
     * Container's getter for PaymentPlanItemBalanceView1.
     * @return PaymentPlanItemBalanceView1
     */
    public ViewObjectImpl getPaymentPlanItemBalanceView1() {
        return (ViewObjectImpl)findViewObject("PaymentPlanItemBalanceView1");
    }

    /**
     * Container's getter for InspectionInfoPaymentPlanItemBalanceLink1.
     * @return InspectionInfoPaymentPlanItemBalanceLink1
     */
    public ViewLinkImpl getInspectionInfoPaymentPlanItemBalanceLink1() {
        return (ViewLinkImpl)findViewLink("InspectionInfoPaymentPlanItemBalanceLink1");
    }

    /**
     * Container's getter for PaymentAllocationView1.
     * @return PaymentAllocationView1
     */
    public ViewObjectImpl getPaymentAllocationView1() {
        return (ViewObjectImpl)findViewObject("PaymentAllocationView1");
    }

    /**
     * Container's getter for PaymentPaymentAllocationLink1.
     * @return PaymentPaymentAllocationLink1
     */
    public ViewLinkImpl getPaymentPaymentAllocationLink1() {
        return (ViewLinkImpl)findViewLink("PaymentPaymentAllocationLink1");
    }

    /**
     * Container's getter for PaymentAllocationView2.
     * @return PaymentAllocationView2
     */
    public ViewObjectImpl getPaymentAllocationView2() {
        return (ViewObjectImpl)findViewObject("PaymentAllocationView2");
    }

    /**
     * Container's getter for UnbilledItemPaymentAllocationLink1.
     * @return UnbilledItemPaymentAllocationLink1
     */
    public ViewLinkImpl getUnbilledItemPaymentAllocationLink1() {
        return (ViewLinkImpl)findViewLink("UnbilledItemPaymentAllocationLink1");
    }

    /**
     * Container's getter for PaymentAllocationView3.
     * @return PaymentAllocationView3
     */
    public ViewObjectImpl getPaymentAllocationView3() {
        return (ViewObjectImpl)findViewObject("PaymentAllocationView3");
    }

    /**
     * Container's getter for BilledItemsViewPaymentAllocationLink1.
     * @return BilledItemsViewPaymentAllocationLink1
     */
    public ViewLinkImpl getBilledItemsViewPaymentAllocationLink1() {
        return (ViewLinkImpl)findViewLink("BilledItemsViewPaymentAllocationLink1");
    }

    /**
     * Container's getter for PaymentAllocationView4.
     * @return PaymentAllocationView4
     */
    public ViewObjectImpl getPaymentAllocationView4() {
        return (ViewObjectImpl)findViewObject("PaymentAllocationView4");
    }

    /**
     * Container's getter for UnbilledItemsPaymentAllocationLink1.
     * @return UnbilledItemsPaymentAllocationLink1
     */
    public ViewLinkImpl getUnbilledItemsPaymentAllocationLink1() {
        return (ViewLinkImpl)findViewLink("UnbilledItemsPaymentAllocationLink1");
    }

    /**
     * Set the varReferenceNumber attribute.
     * @param varReferenceNumber
     */
    public void setVarReferenceNumber(String varReferenceNumber) {
        this.varReferenceNumber = varReferenceNumber;
    }

    /**
     * Container's getter for ThirdPartyCollectHeaderView1.
     * @return ThirdPartyCollectHeaderView1
     */
    public ViewObjectImpl getThirdPartyCollectHeaderView1() {
        return (ViewObjectImpl)findViewObject("ThirdPartyCollectHeaderView1");
    }


    /**
     * Container's getter for ThirdPartyCollAssocView1.
     * @return ThirdPartyCollAssocView1
     */
    public ViewObjectImpl getThirdPartyCollAssocView1() {
        return (ViewObjectImpl)findViewObject("ThirdPartyCollAssocView1");
    }
    
    /**
     *Retrieves parent tpc record to associate the new Type P tpc child record generated for a processed payment.
     * @param invoiceNumber
     * @return
     */
    private Number getTpcId(String invoiceNumber){
        ViewObjectImpl tpcVo = this.getThirdPartyCollectionView1();
        tpcVo.setApplyViewCriteriaName("getThirdPartyCollectionIDViewCriteria");
        tpcVo.setNamedWhereClauseParam("InvoiceNumber", invoiceNumber);
        tpcVo.executeQuery();
        
        RowSetIterator tpcIter = tpcVo.getRowSetIterator();
        Number retVal = null;
        while (tpcIter.hasNext()){
            Row tpcRow = tpcIter.next();
            retVal = (Number) tpcRow.getAttribute("ThirdPartyCollectId");
        }
        tpcIter.closeRowSetIterator();
        return retVal;
        //getThirdPartyCollectionPaymentRefNumber
    }

    /**
     * Returns true if another payment with the same ref number on the same invoice exist, false otherwise.
     * Tests potential duplicate payment.
     * @param invoiceNumber
     * @param refNumber - Payment Referral Number
     * @return
     */
    private Boolean isPaymentReferred(String invoiceNumber, String refNumber){
        ViewObjectImpl tpcVo = this.getThirdPartyCollectionView1();
        tpcVo.setApplyViewCriteriaName("getThirdPartyCollectionPaymentRefNumber");
        tpcVo.setNamedWhereClauseParam("InvoiceNumber", invoiceNumber);
        tpcVo.setNamedWhereClauseParam("RefNumber", refNumber);
        tpcVo.executeQuery();
        
        RowSetIterator tpcIter = tpcVo.createRowSetIterator(null);
        tpcIter.reset();
        Boolean retVal = false;
        if (tpcIter.hasNext()){
            retVal = true;
        }
        tpcIter.closeRowSetIterator();
        return retVal;
        //getThirdPartyCollectionPaymentRefNumber
    }

    
    /**
     *Retrieves the currently active tpc header id at the time the Type P tpc record is created.
     * @return
     */
    
    private Number getCurrentTpcHeaderId(){
        ViewObjectImpl tpcHeaderVo = this.getThirdPartyCollectHeaderView1();
        tpcHeaderVo.setApplyViewCriteriaName("getThirdPartyCollectionHeaderViewCriteria");
        tpcHeaderVo.executeQuery();
        
        RowSetIterator tpcHeaderIter = tpcHeaderVo.createRowSetIterator(null);
        Number retVal = null;
        while (tpcHeaderIter.hasNext()){
            Row tpcHeaderRow = tpcHeaderIter.next();
            retVal = (Number) tpcHeaderRow.getAttribute("TpCollectionHeaderId");
        }
        tpcHeaderIter.closeRowSetIterator();
        return retVal;
    }
    
    /**
     * Create TPC Collection Type P records for invoices that have been referred
     */
    public void createTpcReferral(){
        Row currentInspectionRow = this.getInspectionInformationView1().getCurrentRow();
        String invoiceNumber = (String) currentInspectionRow.getAttribute("InspectionNumber");
        ThirdPartyCollectionUtils tpcUtils = new ThirdPartyCollectionUtils();
        Number tpcId = getTpcId(invoiceNumber);
        
        
        ViewObjectImpl paymentView = this.getPaymentView1();
        oracle.jbo.domain.Number amount = (Number)((oracle.jbo.domain.Number) paymentView.getCurrentRow().getAttribute("PaymentAmount")).round(2);
        String referenceNumber = (String) paymentView.getCurrentRow().getAttribute("PaymentControlNumber");
        Date transactionDate = (Date) paymentView.getCurrentRow().getAttribute("PaymentDate");
        Boolean isPayReferred = null; 
        try {
            isPayReferred = isPaymentReferred(invoiceNumber,tpcUtils.getTPCReferenceNumber(referenceNumber).toString());
            if ( tpcId != null && this.isTPCReferred(invoiceNumber) && !isPayReferred) {
                //create tpc referral
    
                    ViewObject tpcVo = this.getThirdPartyCollectionView1();
                    NameValuePairs tpcNewRow = new NameValuePairs();
                    Number newTpcId = this.getThirdPartyCollectionIdSequence();
                    tpcNewRow.setAttribute("ThirdPartyCollectId", newTpcId);
                    tpcNewRow.setAttribute("DebtorNumber", invoiceNumber);
                    tpcNewRow.setAttribute("TransPaymentEffectiveDate", transactionDate);
                    tpcNewRow.setAttribute("TransactionPaymentAmount", amount);
                    
                    tpcNewRow.setAttribute("ReferenceNumber",tpcUtils.getTPCReferenceNumber(referenceNumber));                
                    tpcNewRow.setAttribute("TpCollectionHeaderId",getCurrentTpcHeaderId()); 
                    tpcVo.insertRow(tpcVo.createAndInitRow(tpcNewRow));//create tpc assoc
                    
                    ViewObject tpcAssocVo = this.getThirdPartyCollAssocView1();
                    NameValuePairs tpcAssocNewRow = new NameValuePairs();
                    tpcAssocNewRow.setAttribute("ThirdPartyCollFromId", tpcId);
                    tpcAssocNewRow.setAttribute("ThirdPartyCollToId", newTpcId);
                    tpcAssocVo.insertRow(tpcAssocVo.createAndInitRow(tpcAssocNewRow));
          
                    System.out.println("Created tpc records without errors" );
                  }
            }
            catch(Exception e){
                System.out.println("Error creating tpc: ");
                e.printStackTrace();
            }
         
    }

    /**
     * Container's getter for ThirdPartyCollectionView1.
     * @return ThirdPartyCollectionView1
     */
    public ViewObjectImpl getThirdPartyCollectionView1() {
        return (ViewObjectImpl)findViewObject("ThirdPartyCollectionView1");
    }


    public void createUnappliedUnbilledItem() {
    }
    
    public boolean isTPCReferred(String invoiceNumber){
        boolean retVal = false;
        try{
            CallableStatement callableStatement = null;
            callableStatement = getDBTransaction().createCallableStatement("begin ? := FUNC_IS_ACTIVE_TPC_REF(?); end;",0);
           
            callableStatement.registerOutParameter(1, Types.NUMERIC);
            callableStatement.setString(2, invoiceNumber);
            callableStatement.executeUpdate();
            Object functionValue = null;
            functionValue = callableStatement.getObject(1);
            if (functionValue != null){
                //BigDecimal val = (BigDecimal) functionValue;
                if (((BigDecimal) functionValue).compareTo(new BigDecimal("1")) == 0){
                    retVal = true;
                }
            }
        }catch(SQLException e){
            e.printStackTrace();
            retVal = false;
            }catch(Exception e){
                e.printStackTrace();
                retVal = false;
            }
        return retVal;
    }
    
    public String getPaymentTypeCode(){
        Row paymentRow = this.getPaymentView1().getCurrentRow();
        return (String) paymentRow.getAttribute("PaymentTypeCode");
    }
    
    /**
     * get deposit slip number from DepositTransmittal table if the local variable depositSlipNumber is not set.
     * 
     * @return  DepositSlipNumber if found. Otherwise, return null.
     */
    private String getDepositSlipNumber() {
        String depositSlip = this.depositSlipNumber;
        if (depositSlip == null) {
            ViewObjectImpl paymentView = this.getPaymentView1();
            Row paymentViewRow = paymentView.getCurrentRow();
            if (paymentViewRow != null) {       
                oracle.jbo.domain.Number depositTransmittalId = (oracle.jbo.domain.Number)paymentViewRow.getAttribute("DepositTransmittalId");
                System.out.println("DepositTransmittalID " + depositTransmittalId);
                ViewObjectImpl depositTransmittalView = getDepositTransmittalView1();
                Key depositTransmittalKey = new Key(new Object[] { depositTransmittalId });
                Row[] depositTransmittalRows = depositTransmittalView.findByKey(depositTransmittalKey, 1);
                if (depositTransmittalRows != null && depositTransmittalRows.length > 0) {
                    Row depositTransmittalRow = depositTransmittalRows[0];
                    depositSlip = (String)depositTransmittalRow.getAttribute("DepositSlipNumber");
                } else {
                    FacesContext fc = FacesContext.getCurrentInstance();
                    FacesMessage fm = new FacesMessage(FacesMessage.SEVERITY_WARN, "", "Could not find Deposit Transmittal for Deposit Transmittal ID " + depositTransmittalId);  
                    fc.addMessage(null, fm);
                }
            }
        }

        System.out.println("DepositSlipNumber " + depositSlip);
        
        if (depositSlip == null || depositSlip.isEmpty()) {
            FacesContext fc = FacesContext.getCurrentInstance();
            FacesMessage fm = new FacesMessage(FacesMessage.SEVERITY_WARN, "", "Missing DepositSlipNumber");  
            fc.addMessage(null, fm);
        }
       
        return depositSlip;
    }//getDepositSlipNumber()
}
